<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICMP Grundlagen Quiz</title>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Bootstrap CSS und JS CDN -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.0.8/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, #8A2BE2, #0000FF);
            margin: 0;
            padding: 20px;
        }

        html, body {
            height: 127%; /* Sets the height to cover the full viewport */
            margin: 0; /* Resets default margin */
            padding: 0; /* Resets default padding */
            /* Your existing background styles */
            background: linear-gradient(to bottom, #8A2BE2, #0000FF);
        }

        h1 {
            text-align: center;
            color: #fff;
        }

        #quiz-container {
            max-width: 600px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .question {
            margin-bottom: 20px;
            color: #582ced;
        }

        .options label {
            display: block;
            margin-bottom: 10px;
            color: black;
        }

        .options input {
            margin-right: 10px;
        }

        #submit-btn {
            background-color: #3d3d3d;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
        }

        /* Stil für das Diagramm */
        #quizResultsChart {
            margin-top: 20px;
        }

        /* Anpassungen für Frage 7 */
        .question:last-child {
            margin-bottom: 0;
        }

        .question:last-child p {
            margin-bottom: 0;
        }

        .btn-liquid {
            display: inline-block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;


            width: 300px;
            height: 100px;

            border-radius: 27px;

            color: #fff;
            font: 700 36px/50px "Droid Sans", sans-serif;
            letter-spacing: 0.05em;
            text-align: center;
            text-decoration: none;
            text-transform: uppercase;
        }

        .btn-liquid .inner {
            position: relative;

            z-index: 2;
        }

        .btn-liquid canvas {
            position: absolute;
            top: -50px;
            right: -50px;
            bottom: -50px;
            left: -50px;

            z-index: 1;
        }

        .btn-liquid:hover .inner,
        .btn-liquid:active .inner {
            color: white;
        }

        .btn-liquid, .btn-liquid:hover, .btn-liquid:active {
            text-decoration: none;
        }
    </style>
</head>

<body>
    <h1>Quiz über das Thema ICMP</h1>
    <div id="quiz-container" style="display: none;">
        <!-- Frage 1 -->
        <div class="question">
            <p>Frage 1: Was ist die Hauptrolle des Internet Control Message Protocol (ICMP)?</p>
            <div class="options">
                <label><input type="radio" name="q1" value="A"> A) Transport von Benutzerdaten</label>
                <label><input type="radio" name="q1" value="B"> B) Austausch von Netzwerkstatusinformationen und Fehlermeldungen</label>
                <label><input type="radio" name="q1" value="C"> C) Verschlüsselung von Daten</label>
                <label><input type="radio" name="q1" value="D"> D) Routing von IP-Paketen</label>
            </div>
        </div>

        <!-- Frage 2 -->
        <div class="question">
            <p>Frage 2: Wofür wird eine ICMP-Nachricht vom Typ 'Destination Unreachable' gesendet?</p>
            <div class="options">
                <label><input type="radio" name="q2" value="A"> A) Wenn ein Router überlastet ist</label>
                <label><input type="radio" name="q2" value="B"> B) Wenn ein Zielnetzwerk nicht erreichbar ist</label>
                <label><input type="radio" name="q2" value="C"> C) Wenn ein IP-Paket manipuliert wurde</label>
                <label><input type="radio" name="q2" value="D"> D) Wenn ein IP-Paket sein Ziel erreicht hat</label>
            </div>
        </div>

        <!-- Frage 3 -->
        <div class="question">
	    <p>Frage 3: Wofür wird das 'Ping'-Kommando verwendet?</p>
            <div class="options">
                <label><input type="radio" name="q3" value="A"> A) Um die Geschwindigkeit einer Internetverbindung zu messen</label>
                <label><input type="radio" name="q3" value="B"> B) Um die Round-Trip-Zeit von Paketen zu messen</label>
                <label><input type="radio" name="q3" value="C"> C) Um die Größe eines Netzwerks zu bestimmen</label>
                <label><input type="radio" name="q3" value="D"> D) Um Firewalls zu konfigurieren</label>
            </div>
        </div>

        <!-- Frage 4 -->
        <div class="question">
            <p>Frage 4: Was bedeutet eine ICMP 'Time Exceeded'-Nachricht?</p>
            <div class="options">
                <label><input type="radio" name="q4" value="A"> A) Dass das Zielnetzwerk überlastet ist</label>
                <label><input type="radio" name="q4" value="B"> B) Dass das 'Time-to-Live' (TTL) Feld eines Pakets auf 0 abgelaufen ist</label>
                <label><input type="radio" name="q4" value="C"> C) Dass ein Paket sein Ziel erreicht hat</label>
                <label><input type="radio" name="q4" value="D"> Dass die Verschlüsselung eines Pakets fehlgeschlagen ist</label>
            </div>
        </div>

        <!-- Frage 5 -->
        <div class="question">
            <p>Frage 5: Welche Rolle spielen ICMP-Nachrichten im Netzwerkmanagement?</p>
            <div class="options">
                <label><input type="radio" name="q5" value="A"> A) Sie werden für die Datenverschlüsselung verwendet</label>
                <label><input type="radio" name="q5" value="B"> B) Sie dienen der Überwachung von Netzwerkgeräten</label>
                <label><input type="radio" name="q5" value="C"> C) Sie regulieren die Internetgeschwindigkeit</label>
                <label><input type="radio" name="q5" value="D"> D) Sie werden für E-Mail-Dienste verwendet</label>
            </div>
        </div>

        <!-- Frage 6 -->
        <div class="question">
            <p>Frage 6: Welche Aussage beschreibt eine Sicherheitsbedrohung im Zusammenhang mit ICMP?</p>
            <div class="options">
                <label><input type="radio" name="q6" value="A"> A) ICMP kann nicht für Netzwerkangriffe verwendet werden</label>
                <label><input type="radio" name="q6" value="B"> B) ICMP wird für die sichere Datenübertragung verwendet</label>
                <label><input type="radio" name="q6" value="C"> C) ICMP kann für Angriffe wie ICMP Flood genutzt werden</label>
                <label><input type="radio" name="q6" value="D"> D) ICMP verhindert alle Arten von Netzwerkangriffen</label>
            </div>
        </div>

        <!-- Frage 7 -->
        <div class="question">
            <p>Frage 7: Welche Limitation hat ICMP in Bezug auf Sicherheit?</p>
            <div class="options">
                <label><input type="radio" name="q7" value="A"> A) Es bietet starke Verschlüsselungsmechanismen</label>
                <label><input type="radio" name="q7" value="B"> B) Es bietet keine Mechanismen wie Verschlüsselung oder Authentifizierung</label>
                <label><input type="radio" name="q7" value="C"> C) Es verhindert automatisch alle Netzwerkangriffe</label>
                <label><input type="radio" name="q7" value="D"> D) Es unterstützt nur veraltete Netzwerkprotokolle</label>
            </div>
        </div>

        <button id="submit-btn" onclick="checkAnswers()">Quiz Abschicken</button>
    </div>

    <!-- Start-Button -->
    <a class="btn-liquid" id="liquidButton">
		<span class="inner" id="start-btn" onclick="startQuiz()">Starte das Quiz</span>
    </a>

    <!-- Ergebnis-Container für das Diagramm -->
    <div id="result-container" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="resultModalLabel"
        aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="resultModalLabel">Quiz Ergebnisse</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <canvas id="quizResultsChart" width="400" height="200"></canvas>
                    <div id="result-text"></div>
                    <div id="solutions"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function startQuiz() {
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('quiz-container').style.display = 'block';
            document.getElementById('liquidButton').style.display = 'none';
        }

        function checkAnswers() {
            var correctAnswers = ['B', 'B', 'B', 'B', 'B', 'C', 'B'];
            var userAnswers = [];

            for (var i = 1; i <= 7; i++) {
                var selectedOption = document.querySelector('input[name="q' + i + '"]:checked');
                if (selectedOption) {
                    userAnswers.push(selectedOption.value);
                } else {
                    userAnswers.push(null);
                }
            }

            var correctCount = 0;
            for (var i = 0; i < correctAnswers.length; i++) {
                if (userAnswers[i] === correctAnswers[i]) {
                    correctCount++;
                }
            }

            var resultText = (correctCount === correctAnswers.length) ? '7/7 du scheiß Streber!' : correctCount + '/' + correctAnswers.length + ' Hör mal zu du Huan!';

            document.getElementById('result-text').innerHTML = resultText;

            var solutionsHtml = '<h4>Lösungen:</h4>';
            for (var i = 0; i < correctAnswers.length; i++) {
                solutionsHtml += '<p>Frage ' + (i + 1) + ': ' + correctAnswers[i] + '</p>';
            }
            document.getElementById('solutions').innerHTML = solutionsHtml;

            // Chart.js
            var ctx = document.getElementById('quizResultsChart').getContext('2d');
            var chart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Richtig', 'Falsch'],
                    datasets: [{
                        data: [correctCount, correctAnswers.length - correctCount],
                        backgroundColor: ['#36A2EB', '#FF6384'],
                        hoverBackgroundColor: ['#36A2EB', '#FF6384']
                    }]
                }
            });

            $('#result-container').modal('show');
        }

        $(function() {
        // Vars
        var pointsA = [],
            pointsB = [],
            $canvas = null,
            canvas = null,
            context = null,
            vars = null,
            points = 8,
            viscosity = 20,
            mouseDist = 70,
            damping = 0.05,
            showIndicators = false;
            mouseX = 0,
            mouseY = 0,
            relMouseX = 0,
            relMouseY = 0,
            mouseLastX = 0,
            mouseLastY = 0,
            mouseDirectionX = 0,
            mouseDirectionY = 0,
            mouseSpeedX = 0,
            mouseSpeedY = 0;

        /**
         * Get mouse direction
         */
        function mouseDirection(e) {
            if (mouseX < e.pageX)
                mouseDirectionX = 1;
            else if (mouseX > e.pageX)
                mouseDirectionX = -1;
            else
                mouseDirectionX = 0;

            if (mouseY < e.pageY)
                mouseDirectionY = 1;
            else if (mouseY > e.pageY)
                mouseDirectionY = -1;
            else
                mouseDirectionY = 0;

            mouseX = e.pageX;
            mouseY = e.pageY;

            relMouseX = (mouseX - $canvas.offset().left);
            relMouseY = (mouseY - $canvas.offset().top);
        }
        $(document).on('mousemove', mouseDirection);

        /**
         * Get mouse speed
         */
        function mouseSpeed() {
            mouseSpeedX = mouseX - mouseLastX;
            mouseSpeedY = mouseY - mouseLastY;

            mouseLastX = mouseX;
            mouseLastY = mouseY;

            setTimeout(mouseSpeed, 50);
        }
        mouseSpeed();

        /**
         * Init button
         */
        function initButton() {
            // Get button
            var button = $('.btn-liquid');
            var buttonWidth = button.width();
            var buttonHeight = button.height();

            // Create canvas
            $canvas = $('<canvas></canvas>');
            button.append($canvas);

            canvas = $canvas.get(0);
            canvas.width = buttonWidth+100;
            canvas.height = buttonHeight+100;
            context = canvas.getContext('2d');

            // Add points

            var x = buttonHeight/2;
            for(var j = 1; j < points; j++) {
                addPoints((x+((buttonWidth-buttonHeight)/points)*j), 0);
            }
            addPoints(buttonWidth-buttonHeight/5, 0);
            addPoints(buttonWidth+buttonHeight/10, buttonHeight/2);
            addPoints(buttonWidth-buttonHeight/5, buttonHeight);
            for(var j = points-1; j > 0; j--) {
                addPoints((x+((buttonWidth-buttonHeight)/points)*j), buttonHeight);
            }
            addPoints(buttonHeight/5, buttonHeight);

            addPoints(-buttonHeight/10, buttonHeight/2);
            addPoints(buttonHeight/5, 0);
            // addPoints(x, 0);
            // addPoints(0, buttonHeight/2);

            // addPoints(0, buttonHeight/2);
            // addPoints(buttonHeight/4, 0);

            // Start render
            renderCanvas();
        }

        /**
         * Add points
         */
        function addPoints(x, y) {
            pointsA.push(new Point(x, y, 1));
            pointsB.push(new Point(x, y, 2));
        }

        /**
         * Point
         */
        function Point(x, y, level) {
        this.x = this.ix = 50+x;
        this.y = this.iy = 50+y;
        this.vx = 0;
        this.vy = 0;
        this.cx1 = 0;
        this.cy1 = 0;
        this.cx2 = 0;
        this.cy2 = 0;
        this.level = level;
        }

        Point.prototype.move = function() {
            this.vx += (this.ix - this.x) / (viscosity*this.level);
            this.vy += (this.iy - this.y) / (viscosity*this.level);

            var dx = this.ix - relMouseX,
                dy = this.iy - relMouseY;
            var relDist = (1-Math.sqrt((dx * dx) + (dy * dy))/mouseDist);

            // Move x
            if ((mouseDirectionX > 0 && relMouseX > this.x) || (mouseDirectionX < 0 && relMouseX < this.x)) {
                if (relDist > 0 && relDist < 1) {
                    this.vx = (mouseSpeedX / 4) * relDist;
                }
            }
            this.vx *= (1 - damping);
            this.x += this.vx;

            // Move y
            if ((mouseDirectionY > 0 && relMouseY > this.y) || (mouseDirectionY < 0 && relMouseY < this.y)) {
                if (relDist > 0 && relDist < 1) {
                    this.vy = (mouseSpeedY / 4) * relDist;
                }
            }
            this.vy *= (1 - damping);
            this.y += this.vy;
        };


        /**
         * Render canvas
         */
        function renderCanvas() {
            // rAF
            rafID = requestAnimationFrame(renderCanvas);

            // Clear scene
            context.clearRect(0, 0, $canvas.width(), $canvas.height());
            context.fillStyle = 'transparent';
            context.fillRect(0, 0, $canvas.width(), $canvas.height());

            // Move points
            for (var i = 0; i <= pointsA.length - 1; i++) {
                pointsA[i].move();
                pointsB[i].move();
            }

            // Create dynamic gradient
            var gradientX = Math.min(Math.max(mouseX - $canvas.offset().left, 0), $canvas.width());
            var gradientY = Math.min(Math.max(mouseY - $canvas.offset().top, 0), $canvas.height());
            var distance = Math.sqrt(Math.pow(gradientX - $canvas.width()/2, 2) + Math.pow(gradientY - $canvas.height()/2, 2)) / Math.sqrt(Math.pow($canvas.width()/2, 2) + Math.pow($canvas.height()/2, 2));

            var gradient = context.createRadialGradient(gradientX, gradientY, 300+(300*distance), gradientX, gradientY, 0);
            gradient.addColorStop(0, '#102ce5');
            gradient.addColorStop(1, '#E406D6');

            // Draw shapes
            var groups = [pointsA, pointsB]

            for (var j = 0; j <= 1; j++) {
                var points = groups[j];

                if (j == 0) {
                    // Background style
                    context.fillStyle = '#1CE2D8';
                } else {
                    // Foreground style
                    context.fillStyle = gradient;
                }

                context.beginPath();
                context.moveTo(points[0].x, points[0].y);

                for (var i = 0; i < points.length; i++) {
                    var p = points[i];
                    var nextP = points[i + 1];
                    var val = 30*0.552284749831;

                    if (nextP != undefined) {
                        // if (nextP.ix > p.ix && nextP.iy < p.iy) {
                        // 	p.cx1 = p.x;
                        // 	p.cy1 = p.y-val;
                        // 	p.cx2 = nextP.x-val;
                        // 	p.cy2 = nextP.y;
                        // } else if (nextP.ix > p.ix && nextP.iy > p.iy) {
                        // 	p.cx1 = p.x+val;
                        // 	p.cy1 = p.y;
                        // 	p.cx2 = nextP.x;
                        // 	p.cy2 = nextP.y-val;
                        // }  else if (nextP.ix < p.ix && nextP.iy > p.iy) {
                        // 	p.cx1 = p.x;
                        // 	p.cy1 = p.y+val;
                        // 	p.cx2 = nextP.x+val;
                        // 	p.cy2 = nextP.y;
                        // } else if (nextP.ix < p.ix && nextP.iy < p.iy) {
                        // 	p.cx1 = p.x-val;
                        // 	p.cy1 = p.y;
                        // 	p.cx2 = nextP.x;
                        // 	p.cy2 = nextP.y+val;
                        // } else {

                            p.cx1 = (p.x+nextP.x)/2;
                            p.cy1 = (p.y+nextP.y)/2;
                            p.cx2 = (p.x+nextP.x)/2;
                            p.cy2 = (p.y+nextP.y)/2;

                            context.bezierCurveTo(p.x, p.y, p.cx1, p.cy1, p.cx1, p.cy1);
                        // 	continue;
                        // }

                        // context.bezierCurveTo(p.cx1, p.cy1, p.cx2, p.cy2, nextP.x, nextP.y);
                    } else {
    nextP = points[0];
                            p.cx1 = (p.x+nextP.x)/2;
                            p.cy1 = (p.y+nextP.y)/2;

                            context.bezierCurveTo(p.x, p.y, p.cx1, p.cy1, p.cx1, p.cy1);
                    }
                }

                // context.closePath();
                context.fill();
            }

            if (showIndicators) {
                // Draw points
                context.fillStyle = '#000';
                context.beginPath();
                for (var i = 0; i < pointsA.length; i++) {
                    var p = pointsA[i];

                    context.rect(p.x - 1, p.y - 1, 2, 2);
                }
                context.fill();

                // Draw controls
                context.fillStyle = '#f00';
                context.beginPath();
                for (var i = 0; i < pointsA.length; i++) {
                    var p = pointsA[i];

                    context.rect(p.cx1 - 1, p.cy1 - 1, 2, 2);
                    context.rect(p.cx2 - 1, p.cy2 - 1, 2, 2);
                }
                context.fill();
            }
        }

        // Init
        initButton();
    });
    </script>
</body>

</html>
